=== [ topic ][  ] ===
[ --- start ---- ]
[ ---  end  ---- ]

=== [ topic ][ window ] ===
[ --- start ---- ]
- line break:
alert("Hello\nHow are you?");
- alert("xxx") == window.alert("xxx")
- window.scrollX
- window.scrollY;
- window.stop; /// stop loading the page
- answer = window.prompt("What is the date today?");
- window.alert(answer)
- window.confirm("question...yes or no?")
var r=confirm("Press a button");
if (r==true)... else...
- window.prompt("xxx");
window.prompt("sometext","defaultText");
var person=prompt("Please enter your name","Harry Potter");
- window.getComputedStyle(thePara, null)
/* when page finish loading */
- window.onload=FunctionToBeInvoked;
[ ---  end  ---- ]

=== [ topic ][ window ][ BOM ] ===
[ --- start ---- ]
- Browser Object Model (BOM)
- All global JavaScript objects, functions, and variables automatically become members of the window object.
- Global variables are properties of the window object.
- Global functions are methods of the window object.
Even the document object (of the HTML DOM) is a property of the window object:
window.document.getElementById("header");
/// is same as
document.getElementById("header");

    window.open() - open a new window
    window.close() - close the current window
    window.moveTo() -move the current window
    window.resizeTo() -resize the current window

Example 1: the || is valid javascript
var w=window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
var h=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
x=document.getElementById("demo");
x.innerHTML="Browser inner window width: " + w + ", height: " + h + "."
[ ---  end  ---- ]

=== [ topic ][ window screen ] ===
[ --- start ---- ]
    screen.availWidth - available screen width
    screen.availHeight - available screen height
[ ---  end  ---- ]

=== [ topic ][ window location ] ===
[ --- start ---- ]
The window.location object can be used to get the current page address (URL) 
and to redirect the browser to a new page.
    location.hostname returns the domain name of the web host
    location.pathname returns the path and filename of the current page
        e.g. /js/js_window_location.asp
    location.port returns the port of the web host (80 or 443)
    location.protocol returns the web protocol used (http:// or https://)
    location.href == returns entire URL of current page
        e.g. http://www.w3schools.com/js/js_window_location.asp

Example 1: loads new url
function newDoc() { window.location.assign("http://www.w3schools.com") }
<input type="button" value="Load new document" onclick="newDoc()">
[ ---  end  ---- ]

=== [ topic ][ window history ] ===
[ --- start ---- ]
    history.back() - same as clicking back in the browser
    history.forward() - same as clicking forward in the browser
[ ---  end  ---- ]

=== [ topic ][ window navigator ] ===
[ --- start ---- ]
txt = "<p>Browser CodeName: " + navigator.appCodeName + "</p>";
txt+= "<p>Browser Name: " + navigator.appName + "</p>";
txt+= "<p>Browser Version: " + navigator.appVersion + "</p>";
txt+= "<p>Cookies Enabled: " + navigator.cookieEnabled + "</p>";
txt+= "<p>Browser Language: " + navigator.language + "</p>";
txt+= "<p>Browser Online: " + navigator.onLine + "</p>";
txt+= "<p>Platform: " + navigator.platform + "</p>";
txt+= "<p>User-agent header: " + navigator.userAgent + "</p>";
txt+= "<p>User-agent language: " + navigator.systemLanguage + "</p>";

document.getElementById("example").innerHTML=txt;

note:
The information from the navigator object can often be misleading, and should 
not be used to detect browser versions because:

    The navigator data can be changed by the browser owner
    Some browsers misidentify themselves to bypass site tests
    Browsers cannot report new operating systems, released later than the browser

Since different browsers support different objects, you can use objects to 
detect browsers. For example, since only Opera supports the property 
"window.opera", you can use that to identify Opera.{
    }

Example: if (window.opera) {...some action...}

[ ---  end  ---- ]

=== [ topic ][ document ] ===
[ --- start ---- ]
- give access to the contents of the HTML document
- can get title, URL...
[ ---  end  ---- ]

=== [ topic ][ DOM ][ getElementByXXX ][ finding element ] ===
[ --- start ---- ]
- getElementById
- document.getElementByTag("input"); /// return a list of input element, use for loop to iterate
document.getElementsByClassName()

The following HTML object collections are accesible:
document.anchors
document.forms
document.images
document.links

Example 1:
var x=document.getElementById("main");
var y=x.getElementsByTagName("p");

Example 2:
<form id="frm1" action="form_action.asp">
  First name: <input type="text" name="fname" value="Donald"><br>
  Last name: <input type="text" name="lname" value="Duck"><br>
  <input type="submit" value="Submit">
</form>
function myFunction() {
var x = document.getElementById("frm1");
var txt = "";
for (var i=0;i<x.length;i++) { txt = txt + x.elements[i].value + "<br>"; }
document.getElementById("demo").innerHTML=txt;
}
<button onclick="myFunction()">Try it</button>
@@@ result returned: Donald Duck Submit

[ ---  end  ---- ]

=== [ topic ][ DOM ][ changing html element ] ===
[ --- start ---- ]
document.write(text)
document.getElementById(id).innerHTML=
document.getElementById(id).attribute=
document.getElementById(id).style.attribute=
[ ---  end  ---- ]

=== [ topic ][ DOM ][ changing ][ attribute ] ===
[ --- start ---- ]
document.getElementById("image").src="landscape.jpg";

Example 2:
var p = document.getElementById("kenParaId");
p.setAttribute("class", "KenClass");

Example 3:
var btn = document.getElementById("mybtn");
btn.removeAttribute("disabled");
btn.setAttribute("value", "new content");
[ ---  end  ---- ]

=== [ topic ][ DOM ][ changing ][ style ] ===
[ --- start ---- ]
document.getElementById(id).style.property=new style

Example 1:
document.getElementById("kenPara").style.background="yellow";
[ ---  end  ---- ]

=== [ topic ][ DOM ][ adding or deleting element ] ===
[ --- start ---- ]
document.createElement()
document.removeChild()
document.appendChild()
document.replaceChild()
[ ---  end  ---- ]

=== [ topic ][ adding event handler ] ===
[ --- start ---- ]
document.getElementById(id-xx).onclick=function(){...code...}
[ ---  end  ---- ]

=== [ topic ][ event ] ===
[ --- start ---- ]
- <a onclick="runthisfunction()"></a>
- document.getElementById("myLink").addEventListener("click", "runWhenClick", true)
- addEventListener(event, callback-function, event-flow-model)
- if event-flow-model == true, then capture model is used
- two type of event flow model: 
    = event capturing: handled initially by parent then by the child element
    = event bubbling: descendants receive event first before parent and further ancestor
[ ---  end  ---- ]

=== [ topic ][ event ][ timing ] ===
[ --- start ---- ]
- var myInterval = window.setInterval("javascript function", miliseconds); /// forever loop
- window.clearInterval(intervalVariable)
    e.g. clearInterval(myInterval)
- setTimeout("javascript function", miliseconds); /// execute once only
- window.clearTimeout(timeoutVariable)

Example 0:
/// the alert box will repeat every 3s, forever.
 setInterval(function(){alert("Hello")},3000);

Example 1:
function clock(){
    ...
    setTimeout('clock()',50); /// repeat this function
}
<body onload="clock()">
[ ---  end  ---- ]

=== [ topic ][ insert ] ===
[ --- start ---- ]
- <script src="xxx.js"></script> can be placed in <head> or <body>
- script behave as if it was located exactly where the <script> tag is placed

Example:
<body>
<script src="myScript.js"></script>
</body>
[ ---  end  ---- ]

=== [ topic ][ script tag ] ===
[ --- start ---- ]
<script type="text/javascript" src="xxx.js">
... script ...
</script>
[ ---  end  ---- ]

=== [ topic ][ write html ] ===
[ --- start ---- ]
document.write("<h1>This is a heading</h1>");
document.write("<p>This is a paragraph</p>");
[ ---  end  ---- ]

=== [ topic ][ button ] ===
[ --- start ---- ]
<button type="button" onclick="alert('Welcome!')">Click Me!</button>
[ ---  end  ---- ]

=== [ topic ][ innerHTML ] ===
[ --- start ---- ]
Example 1:
<script>
function myFunction() {
document.getElementById("demo").innerHTML = Date(); }
</script>
<p id="demo"></p>
<button type="button" onclick="myFunction()">Try it</button>

Example 2: Changing html content
x=document.getElementById("demo")  //Find the element
x.innerHTML="Hello JavaScript";    //Change the content
[ ---  end  ---- ]

=== [ topic ][ src ][ match ] ===
[ --- start ---- ]
<script>
function changeImage() {
    element=document.getElementById('myimage')
        if (element.src.match("bulbon")) {
            element.src="pic_bulboff.gif";
        } else {
            element.src="pic_bulbon.gif";
        }
}
</script>

<img id="myimage" onclick="changeImage()"
src="pic_bulboff.gif" width="100" height="180">

<p>Click the light bulb to turn on/off the light</p>
[ ---  end  ---- ]

=== [ topic ][ style ] ===
[ --- start ---- ]
x=document.getElementById("demo") // Find the element
x.style.color="#ff0000";          // Change the style

xxx.style.backgroundColor="green"
[ ---  end  ---- ]

=== [ topic ][ value ] ===
[ --- start ---- ]
to retrieve content from a HTML tag:
- use value for input tag like <input>
- use innerHTML for element tag <span>
function myFunction() {
    var x=document.getElementById("demo").value;
    if(x==""||isNaN(x))
        {
        alert("Not Numeric");
        }
}
[ ---  end  ---- ]

=== [ topic ][ function ][ named ] ===
[ --- start ---- ]
Named function expression.
var foo = function() { ... }

Example 1:
var greet = function( person, greeting ) {
    var text = greeting + ", " + person;
    console.log( text );
};
greet( "Rebecca", "Hello" ); // "Hello, Rebecca"

Example 2:
// A function that returns a value.
var greet = function( person, greeting ) {
    var text = greeting + ", " + person;
    return text;
};
 
console.log( greet( "Rebecca", "Hello" ) ); // "Hello, Rebecca"
[ ---  end  ---- ]

=== [ topic ][ function ][ return another function ] ===
[ --- start ---- ]
var greet = function( person, greeting ) {
    var text = greeting + ", " + person;
    return function() {
        console.log( text );
    };
};
var greeting = greet( "Rebecca", "Hello" );
greeting(); // "Hello, Rebecca"
[ ---  end  ---- ]

=== [ topic ][ function ] ===
[ --- start ---- ]
Immediately-Invoked Function Expression (IIFE)
A common pattern in JavaScript is the immediately-invoked function expression.
This pattern creates a function expression and then immediately executes the
function. This pattern is extremely useful for cases where you want to avoid
polluting the global namespace with code – no variables declared inside of the
function are visible outside of it.

// An immediately-invoked function expression.
(function() {
    var foo = "Hello world";
})();
console.log( foo ); // undefined!
[ ---  end  ---- ]

=== [ topic ][ function ][ function as param ] ===
[ --- start ---- ]
var myFn = function( fn ) {
    var result = fn();
    console.log( result );
};
 
// Logs "hello world"
myFn( function() {
    return "hello world";
});
[ ---  end  ---- ]

=== [ topic ][ function ][ named function as param ] ===
[ --- start ---- ]
var myFn = function( fn ) {
    var result = fn();
    console.log( result );
};
 
var myOtherFn = function() {
    return "hello world";
};
 
myFn( myOtherFn ); // "hello world"
[ ---  end  ---- ]

=== [ topic ][ function ][ parameter ] ===
[ --- start ---- ]
Example 1:
<button onclick="myFunction('Harry Potter','Wizard')">Try it</button>

<script>
function myFunction(name,job) {
alert("Welcome " + name + ", the " + job); }
</script>
[ ---  end  ---- ]

=== [ topic ][ function ][ optional parameter ] ===
[ --- start ---- ]
function myFunction(param){
    if (typeof(param) == "undefined") {
        /// no parameter passed in
    }

    if ( var i=0; i< arguments.length; i++ ){
        /// extra option param from arguments[i] ... 
    }
}
[ ---  end  ---- ]

=== [ topic ][ function ][ array parameter ] ===
[ --- start ---- ]
function myFunction(param){
    while(param.length > 0 ){ 
        var arg = param.shift();
        ...
    }
}
[ ---  end  ---- ]

=== [ topic ][ function ][ return ] ===
[ --- start ---- ]
Example 1:
function myFunction(a,b) {
return a*b;
}

document.getElementById("demo").innerHTML=myFunction(4,3);
[ ---  end  ---- ]

=== [ topic ][ function ][ variable ] ===
[ --- start ---- ]
- local variable, declared using var
   var local_var = 5;
[ ---  end  ---- ]

=== [ topic ][ function ][ private method ] ===
[ --- start ---- ]
function Restaurant(param)
{
    var myPrivateVar;

    var private_stuff = function()   // Only visible inside Restaurant()
    {
        myPrivateVar = "I can set this here!";
    }

    this.use_restroom = function()   // use_restroom is visible to all
    {
        private_stuff();
    }

    this.buy_food = function()    // buy_food is visible to all
    {
        private_stuff();
    }

    this.convertLower = function ()
    {
        return privateFunction(param);
    }

    function privateFunction(param){
        return param.toLowerCase();
    }
}

from external:
var testObj = new Restaurant();
/// won't work
testObj.privateFunction("Testing");
/// working
testObj.convertLower("Testing");
[ ---  end  ---- ]

=== [ topic ][ sibling ] ===
[ --- start ---- ]
<div id="foo1"></div>
<div id="foo2"></div>
<div id="foo3"></div>

document.getElementById('foo2').nextSibling; // #foo3
document.getElementById('foo2').previousSibling; // #foo1
[ ---  end  ---- ]

=== [ topic ][ sibling ][ ignore whitespace] ===
[ --- start ---- ]
- in non-IE browsers, whitespace between elements in HTML is considered 
a text node. You may want to ignore these whitespace nodes when considering 
what the next sibling of each link is. The following will do that:

var menu = document.getElementById('menu');
var links = menu.getElementsByTagName('a');

function isWhitespace(node) {
    return node.nodeType == 3 && /^\s*$/.test(node.data);
}

// Iterate over the links
for (var i = 0, len = links.length, link, next; i < len; ++i) {
    link = links[i];
    next = link.nextSibling;
    if (next && isWhitespace(next)) {
        next = next.nextSibling;
    }
    if (next && next.nodeName == "DIV") {
        alert("Next sibling is DIV! " + link.innerHTML);
    }
}
[ ---  end  ---- ]

=== [ topic ][ mouseover ] ===
[ --- start ---- ]
Example 1:
var lastID = null;

var handleMouseover = function (e) {
    var target = e.target || e.srcElement;
    lastID = target.id;
};

if (document.addEventListener) {
    document.addEventListener('mouseover', handleMouseover, false);
}
else {
    document.attachEvent('onmouseover', handleMouseover);
}
[ ---  end  ---- ]

=== [ topic ][ onclick ] ===
[ --- start ---- ]
- function name needed to be quoated else won't be called
/// will not be called
<p id="para" onclick=changeContent()> This will be changed once clicked!  </p>

/// ok!
<p id="para" onclick="changeContent()"> This will be changed once clicked!  </p>

[ ---  end  ---- ]

=== [ topic ][ var ] ===
[ --- start ---- ]
- JavaScript is a loosely typed language, which means that it will 
  “automagically” cast variables into other types when necessary (i.e. when 
  adding a Number to a String)
var number = 5;
var string = "hello";
var isTrue = true;
var isTrue = false;
/// false = { 0, -0, null, "", false, undefined, NaN }
var array = null; /// contain nothing
/// undefined variables can be test by using undefined keyword
var sex = undefined;
typeof(sex); /// output undefined

/// declare the type of variable, but not assigning value
var newString = new String();
var newNum = new Num();
var newNum = new Num("5");
[ ---  end  ---- ]

=== [ topic ][ var ][ define ] ===
[ --- start ---- ]
// This works:
var test = 1;
var test2 = function() { ... };
var test3 = test2( test );
 
// And so does this: multiple declaration
var test4 = 1,
    test5 = function() { ... },
    test6 = test2( test );

/// var can be left uninitialized
var x;
x === undefined; // true
[ ---  end  ---- ]

=== [ topic ][ var ][ boolean ] ===
[ --- start ---- ]
// Boolean values.
var okay = true;
var fail = false;

Example 1:
if("0") {  // this will run because "0" is true  }  
if("false") {  // this will run because "false" is true  }  

check:
Boolean(0);    // false  
Boolean("0");  // true 

or check with double exclaimation
!!0;    // false  
!!"0";  // true 
[ ---  end  ---- ]

=== [ topic ][ boolean ][ conditional ][ truthy and falsy ] ===
[ --- start ---- ]
- True
// Values that evaluate to true:
"0";  /// take note!!! string is true!!!
"any string";
[]; // An empty array.
{}; // An empty object.
1; // Any non-zero number.

- False
// Values that evaluate to false:
""; // An empty string.
NaN; // JavaScript's "not-a-number" variable.
null;
undefined; // Be careful -- undefined can be redefined!
0; // The number zero.
[ ---  end  ---- ]

=== [ topic ][ var ][ null and undefined ] ===
[ --- start ---- ]
// Define a null value.
var foo = null;
 
// Two ways to achieve an undefined value.
var bar1 = undefined;
var bar2;
[ ---  end  ---- ]

=== [ topic ][ null ] ===
[ --- start ---- ]
the common way:
var second, first = "something";
if (first !== null || typeof first !== "undefined" || first !== '') {
second = first;
}
console.log(second);

shorthand:
var second, first = "something";
second = first || "";
console.log(second);
[ ---  end  ---- ]

=== [ topic ][ undefined ] ===
[ --- start ---- ]
- typeof an yet defined variable belong to "undefined" type
- "undefined" type vs undefined is different!!!:w

foo;  // ReferenceError: foo is not defined  
// debug
try {  
  foo;  
} catch(e) {  
  e.message;  // "foo is not defined"  
}  
[ ---  end  ---- ]

=== [ topic ][ null vs undefined ] ===
[ --- start ---- ]
- null value and undefined valus is same, but null has typeof object, yet 
  undefined has typeof undefined
>> window.hello
    null
>> window.hello.something
    window.hello has no properties
>> window.hello == null
    true
>> window.hello === null
    false
>> window.hello === undefined
    true
>> if (window.hello) { alert('truthy'); } else { alert('falsy'); } // will print falsy.
    null
>> window.hello == undefined
    true
>> null == undefined
    true // 
>> null
    null
>> undefined
    null
>> typeof null
    object
>> typeof undefined
    undefined
[ ---  end  ---- ]

=== [ topic ][ object ] ===
[ --- start ---- ]
- The simplest way to create an object is either through the Object constructor
  or the shorthand syntax known as object literal. These simple objects are
  unordered key/value pairs. The key is formally known as a property and the
  value can be any valid JavaScript type, even another object. To create or
  access a property on an object, we use what is known as "dot notation" or
  "bracket notation."
Example 1:
// Creating an object with the constructor:
var person1 = new Object;
 
person1.firstName = "John";
person1.lastName = "Doe";
 
alert( person1.firstName + " " + person1.lastName );
 
// Creating an object with the object literal syntax:
var person2 = {
    firstName: "Jane",
    lastName: "Doe"
};
 
alert( person2.firstName + " " + person2.lastName );

// As mentioned, objects can also have objects as a property.
var people = {};
 
people[ "person1" ] = person1;
people[ "person2" ] = person2;
 
alert( people[ "person1" ].firstName );
alert( people[ "person2" ].firstName );

// Properties that have not been created are undefined.
var person = { name: "John Doe" };
alert( person.email ); // undefined
[ ---  end  ---- ]

=== [ topic ][ object ][ prototype ] ===
[ --- start ---- ]
- Every javascript object has an internal property call [[Prototype]]
- can be checked via obj.propName or obj['propName']
- if such propName property is not exists (by using 
  obj.hasOwnProperty('propName')), the runtime looks up the property in the 
  object referenced by [[Prototype]] instead.
  == if the prototype-object also doesn't have such property, its prototype is 
  checked in turn, thus walking the original obj's prototype-chain until a match 
  is found or its end is reached

Example 1:
// Define a functional object to hold persons in JavaScript
var Person = function(name) {
    this.name = name;
};

// Add dynamically to the already defined object a new getter
Person.prototype.getName = function() {
    return this.name;
};

// Create a new object of type Person
var john = new Person("John");

// Try the getter
alert(john.getName());

// If now I modify person, also John gets the updates
Person.prototype.sayMyName = function() {
    alert('Hello, my name is ' + this.getName());
};

// Call the new method on john
john.sayMyName();

// to link with conventional java class.. this would be 
// class Person{ String name;
//     Person(name){ this.name=name;}
//     String getname() { return this.name; }
//     void sayMyName() { println("Hello, my name is "+this.getName());}
// }
// 
// class Customer extends Person {
//      
// }

/// Until now I've been extending the base object, now I create another object and then inheriting from Person.

// Create a new object of type Customer by defining its constructor. It's not 
// related to Person for now.
var Customer = function(name) {
    this.name = name;
};

// Now I link the objects and to do so, we link the prototype of Customer to 
// a new instance of Person. The prototype is the base that will be used to 
// construct all new instances and also, will modify dynamically all already 
// constructed objects because in JavaScript objects retain a pointer to the 
// prototype
Customer.prototype = new Person();     

// Now I can call the methods of Person on the Customer, let's try, first 
// I need to create a Customer.
var myCustomer = new Customer('Dream Inc.');
myCustomer.sayMyName();

// If I add new methods to Person, they will be added to Customer, but if I
// add new methods to Customer they won't be added to Person. Example:
Customer.prototype.setAmountDue = function(amountDue) {
    this.amountDue = amountDue;
};
Customer.prototype.getAmountDue = function() {
    return this.amountDue;
};

// Let's try:       
myCustomer.setAmountDue(2000);
alert(myCustomer.getAmountDue());
While as said I can't call setAmountDue(), getAmountDue() on a Person.

// The following statement generates an error.
john.setAmountDue(1000);
Example 2: internal prototyping
var myobject = {
    sayhello: function(){
        console.log("hello");
    },
    myname: 'Rebecca'
};

myobject.sayhello();
console.log(myobject.myname);

Example 3: key-pair. key can be a string, number etc
var myObject = {
    validIdentifier: 123,
    "some string": 456,
    99999: 789
};
[ ---  end  ---- ]

=== [ topic ][ number ][ format ] ===
[ --- start ---- ]
- MAX_VALUE
- MIN_VALUE
- NEGATIVE_INFINITY
- NaN
toExponential()
toFixed()
toLocaleString()
toPrecision()
toString()
[ ---  end  ---- ]

=== [ topic ][ string ] ===
[ --- start ---- ]
- charAt(index) - return char @ index
- charCodeAt(index) - return Unicode value
- concat()
- fromCharCode() - convert Unicode value to a char. e.g. convert 65 to 'A'
- indexOf() - return the first occurence of a search string
- lastIndexOf()
- match()
- replace()
- search()
- slice()
- split()
- substr()
- string.substring(start,end)
- toLocaleLowerCase()
- toLocaleUpperCase
- toLowerCase
- toUpperCase
- valueOf() - return primitive value of a string's object.
[ ---  end  ---- ]

=== [ topic ][ operator ] ===
[ --- start ---- ]
%= modulus
=== (compare value and data type)
== compare value
[ ---  end  ---- ]

=== [ topic ][ operator ][ concatenation ][ + ] ===
[ --- start ---- ]
var foo = "hello";
var bar = "world";
console.log( foo + " " + bar ); // "hello world"

Example 2:
// Addition vs. Concatenation
var foo = 1;
var bar = "2";
console.log( foo + bar ); // 12 (string)

var foo = 1;
var bar = "2";
console.log( foo + Number(bar) ); // 3

Example 3:
// Forcing a string to act as a number (using the unary plus operator).
console.log( foo + +bar ); // 3
[ ---  end  ---- ]

=== [ topic ][ operator ][ pre-increment ][ post-increment ] ===
[ --- start ---- ]
// Incrementing and decrementing
// The pre-increment operator increments the operand before any further processing.
var i = 1;
console.log( ++i ); // 2 - because i was incremented before evaluation
console.log( i );   // 2
 
// The post-increment operator increments the operand after processing it.
var i = 1;
console.log( i++ ); // 1 - because i was evaluated to 1 and _then_ incremented
console.log( i );   // 2 - incremented after using it
[ ---  end  ---- ]

=== [ topic ][ operator ][ logical ] ===
[ --- start ---- ]
var foo = 1;
var bar = 0;
var baz = 2;
// returns 1, which is true
foo || bar;
// returns 1, which is true
bar || foo;
// returns 0, which is false
foo && bar;
// returns 2, which is true
foo && baz;
// returns 1, which is true
baz && foo;

// Do something with foo if foo is truthy.
foo && doSomething( foo );
 
// Set bar to baz if baz is truthy;
// otherwise, set it to the return value of createBar()
var bar = baz || createBar();
[ ---  end  ---- ]

=== [ topic ][ operator ][ compare ] ===
[ --- start ---- ]
var foo = 1;
var bar = 0;
var baz = "1";
var bim = 2;
foo == bar; // false
foo != bar; // true
foo == baz; // true; but note that the types are different
foo === baz;             // false
foo !== baz;             // true
foo === parseInt( baz ); // true
foo > bim;  // false
bim > baz;  // true
foo <= baz; // true
[ ---  end  ---- ]

=== [ topic ][ operator ][ conditional ][ ternary ] ===
[ --- start ---- ]
// Set foo to 1 if bar is true; otherwise, set foo to 0:
var foo = bar ? 1 : 0;
[ ---  end  ---- ]

=== [ topic ][ conditional ] ===
[ --- start ---- ]
var foo = true;
var bar = false;
 
if ( bar ) { // This code will never run.
    console.log( "hello!" ); }
 
if ( bar ) { ...  } else { ...  }
[ ---  end  ---- ]

=== [ topic ][ conditional ][ switch ] ===
[ --- start ---- ]
- switch statements have somewhat fallen out of favor in js
- the same behaviour can be accomplished by creating an object that has more 
  potential for resue or testing. see example 2.
Example 1:
switch ( foo ) {
    case "bar":
        alert( "the value was bar -- yay!" ); break;
    case "baz":
        alert( "boo baz :(" ); break;
    default:
        alert( "everything else is just ok" );
}

Example 2:
var stuffToDo = {
    "bar": function(){
        alert(...);
    },

    "baz":function(){
        alert(...);
    },

    "default": function(){
        alert(...);
    }
};

// Check if the property exists in the object.
if ( stuffToDo[ foo ] ) {
    // This code won't run.
    stuffToDo[ foo ]();
 
} else {
    // This code will run.
    stuffToDo[ "default" ]();
 
}
[ ---  end  ---- ]

=== [ topic ][ HTML wrapper ] ===
[ --- start ---- ]

[ ---  end  ---- ]

=== [ topic ][ date ] ===
[ --- start ---- ]
- toJSON() - output to JSON format
Date.prototype.toUTCString()
dateObj.toUTCString()

Example 1:
var today = new Date();
var UTCstring = today.toUTCString();
// Mon, 03 Jul 2006 21:44:38 GMT
[ ---  end  ---- ]

=== [ topic ][ date ][ time ] ===
[ --- start ---- ]
UTC = Coordinated Universal Time
- most of the time zones on land are offset from UTC by a whole number of hours (UTC-12 to UTC+14)
- measured with atomic clock
- approximates GMT with a tolerance of 0.9 seconds
Greenwich Mean Time (GMT)
- measured with the sun
From programming point of view, both are considered same...

Unix epoch is the time 00:00:00 UTC on 1 January 1970
Note that a 32-bit signed integer using 1970-1-1 as its epoch can represent 
dates up to 2038-1-19, on which date it will wrap around to 1901-12-13.
[ ---  end  ---- ]

=== [ topic ][ regular expression ] ===
[ --- start ---- ]
.  = any character except an end-of-line character
\w = alphabetic char
\W = character that isn't associate with words
\d = digit
\D = non-digit
\s = white space character, including tab, space, form feed, newline, and CR return
\S = non-whitespace character
\b = search at beginning or end of a word
\B = search for a character that doesn't appear at the beginning or end of a word
\0 = null (NUL) character
\n = newline character
\f = formfeed character
\r = carriage return
\t = tab
\v = vertical tab
\xxx = octal number. e.g. A=\101
\xdd = hexadecimal number. e.g. A=\x41
\uxxxx = unicode character. e.g. A=\u0041

n+ :: at least one n
n* :: zero or more n
n? :: zero or one n
n{X} :: n for X times. e.g. A{3} = AAA
n{minX, maxY} :: minimum x time occurences of n and maximum y time occurences of n
n{minX, } :: minimum x time occurences of n, and no limit on maximum occurences
n$ :: n at end of string
^n :: n at beginning of String
?=n :: find a string followed by specific string n. e.g. ?=ken, any string with aken, bken...
?!n :: find a string not followed by specific string n

modifiers:
i = case insensitive
g = global
m = search on all of the lines in a search string that contains end-of-line
    characters rather than searching just the first line

properties of RegExp:
ignoreCase : return true when i modifiers is set
global : return true when g modifier is set
multiline : return true if m modifier is set
lastIndex : specifies the index at which the next search should begin
source : the search expression used by RegExp

methods provided by RegExp:
- exec() : performs a test of the search expression against the search string and returns the result
- test() : performs a test of the search expression against the search string 
           and returns true when the search expression appears within the search string

other notes:
- compile() is deprecated. As the compilation is now automatically occurs when create the RegExp object
[ ---  end  ---- ]

=== [ topic ][ built-in function ] ===
[ --- start ---- ]
toString
encodeURI (check escape())
    replace space as %20
decodeURI
    decode what encodeURI has performed
decodeComponent
    protocl : HTTP, HTTPS, FTP, SMTP, NNTP
    Host: blog.ken.common
    port Number:
    path: fully defined location or default path will be used
    query string:
escape - deprecated!
    escape("encode this string!") ==> (encode%20this%20string%21)
unescape - deprecated!
    decode what escape() has performed
eval
    accepts a string that contains a script and then executes the string content as a script
    disadvantage: 
        - prone to security problem through injection attacks
        - harder to debug, normal tools can't be used
        - run slowly as browser can't compile and cache it
isFinite
isNaN
Number()
    - change to native number
parseFloat
    parse a string and return a floating point number
parseInt
    parse a string and returns an integer
String 
    convert value to a string

Example 1:
decodeURIComponent('your%20funky%20string');
decodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"); // "JavaScript_шеллы"
[ ---  end  ---- ]

=== [ topic ][ encoreURI vs encodeURIComponen ] ===
[ --- start ---- ]
- encodeURI is intended for use on the full URI.
- encodeURIComponent is intended to be used on URI components that is any 
  part that lies between separators (; / ? : @ & = + $ , #).

So, in encodeURIComponent these separators are encoded also because they are 
regarded as text and not special characters.
[ ---  end  ---- ]

=== [ topic ][ problem ] ===
[ --- start ---- ]
Problem: nothing write to html when click on function
Cause: the innerHTML was written as innerHtml
Reminder: js is case-sensitve!
[ ---  end  ---- ]

=== [ topic ][ array ] ===
[ --- start ---- ]
- shift()
- unshift()
var myarray = new Array()
myarray[0] = "text1";
myarray[1] = "text1";

var array1 = new Array("text1", "text2");
/// preferred way
var array2 = [ "text1", "text2" ];
// Creating an array with the array literal syntax:
var bar = [];

- length of array
array1.length

// The array literal returns a foo.length value of 1:
var foo = [ 100 ];
alert( foo[ 0 ] ); // 100
alert( foo.length ); // 1
 
// The array constructor returns a bar.length value of 100:
var bar = new Array( 100 );
alert( bar[ 0 ] ); // undefined
alert( bar.length ); // 100

Example 1:
var foo = [];
foo.push( "a" );
foo.push( "b" );
alert( foo[ 0 ] ); // a
alert( foo[ 1 ] ); // b
alert( foo.length ); // 2
 
foo.pop();
alert( foo[ 0 ] ); // a
alert( foo[ 1 ] ); // undefined
alert( foo.length ); // 1
 
foo.unshift( "z" );
alert( foo[ 0 ] ); // z
alert( foo[ 1 ] ); // a
alert( foo.length ); // 2
 
foo.shift();
alert( foo[ 0 ] ); // a
alert( foo[ 1 ] ); // undefined
alert( foo.length ); // 1

Example 2:
var myArray = [ "hello", "world", "!" ];
for ( var i in myArray ) {
    console.log( myArray[ i ] );
}
[ ---  end  ---- ]

=== [ topic ][ array ][ loop ] ===
[ --- start ---- ]
[ foreach ]
// Native .forEach()
function printElement( elem ) {
    console.log( elem ); }
function printElementAndIndex( elem, index ) {
    console.log( "Index " + index + ": " + elem ); }
function negateElement( elem, index, array ) {
    array[ index ] = -elem; }
 
myArray = [ 1, 2, 3, 4, 5 ];
// Prints all elements to the console
myArray.forEach( printElement );
// Prints "Index 0: 1", "Index 1: 2", "Index 2: 3", ...
myArray.forEach( printElementAndIndex );
// myArray is now [ -1, -2, -3, -4, -5 ]
myArray.forEach( negateElement );
[ ---  end  ---- ]

=== [ topic ][ array ][ concatenate ] ===
[ --- start ---- ]
var myArray = [ 2, 3, 4 ];
var myOtherArray = [ 5, 6, 7 ];
var wholeArray = myArray.concat( myOtherArray ); // [ 2, 3, 4, 5, 6, 7 ]
[ ---  end  ---- ]

=== [ topic ][ array ][ join ] ===
[ --- start ---- ]
// Joining elements
var myArray = [ "hello", "world", "!" ];
// The default separator is a comma.
console.log( myArray.join() );     // "hello,world,!"
// Any string can be used as separator...
console.log( myArray.join( " " ) );  // "hello world !";
console.log( myArray.join( "!!" ) ); // "hello!!world!!!";
// ...including an empty one.
console.log( myArray.join( "" ) );   // "helloworld!"
[ ---  end  ---- ]

=== [ topic ][ array ][ pop ] ===
[ --- start ---- ]
// Pushing and popping
var myArray = [];
myArray.push( 0 ); // [ 0 ]
myArray.push( 2 ); // [ 0 , 2 ]
myArray.push( 7 ); // [ 0 , 2 , 7 ]
myArray.pop();     // [ 0 , 2 ]
[ ---  end  ---- ]

=== [ topic ][ array ][ reverse ] ===
[ --- start ---- ]
var myArray = [ "world" , "hello" ];
myArray.reverse(); // [ "hello", "world" ]
[ ---  end  ---- ]

=== [ topic ][ array ][ shift ] ===
[ --- start ---- ]
Example 1: shift
var myArray = [];
myArray.push( 0 ); // [ 0 ]
myArray.push( 2 ); // [ 0 , 2 ]
myArray.push( 7 ); // [ 0 , 2 , 7 ]
myArray.shift();   // [ 2 , 7 ]

Example 2: unshift
var myArray = [];
myArray.unshift( 0 ); // [ 0 ]
myArray.unshift( 2 ); // [ 2 , 0 ]
myArray.unshift( 7 ); // [ 7 , 2 , 0 ]
[ ---  end  ---- ]

=== [ topic ][ array ][ slice ] ===
[ --- start ---- ]
var myArray = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
var newArray = myArray.slice( 3 );
 
console.log( myArray );  // [ 1, 2, 3, 4, 5, 6, 7, 8 ]
console.log( newArray ); // [ 4, 5, 6, 7, 8 ]
[ ---  end  ---- ]

=== [ topic ][ array ][ splice ] ===
[ --- start ---- ]
- Removes a certain amount of elements and adds new ones at the given index. 
myArray.splice( index, length, values, ... );
Index – The starting index.
Length – The number of elements to remove.
Values – The values to be inserted at the index position.

Example 1:
var myArray = [ 0, 7, 8, 5 ];
/// remove 7,8 (7 is index one), then insert 2,3,4
myArray.splice( 1, 2, 1, 2, 3, 4 );
console.log( myArray ); // [ 0, 1, 2, 3, 4, 5 ]
[ ---  end  ---- ]

=== [ topic ][ array ][ sort ] ===
[ --- start ---- ]
var myArray = [ 3, 4, 6, 1 ];
myArray.sort(); // 1, 3, 4, 6
function descending( a, b ) {
    return b - a;
}
var myArray = [ 3, 4, 6, 1 ];
myArray.sort( descending ); // [ 6, 4, 3, 1 ]
[ ---  end  ---- ]

=== [ topic ][ type checking ][ === ] ===
[ --- start ---- ]
// Checking the type of an arbitrary value.
 
var myValue = [ 1, 2, 3 ];
 
// Using JavaScript's typeof operator to test for primitive types:
typeof myValue === "string"; // false
typeof myValue === "number"; // false
typeof myValue === "undefined"; // false
typeof myValue === "boolean"; // false
 
// Using strict equality operator to check for null:
myValue === null; // false
 
// Using jQuery's methods to check for non-primitive types:
jQuery.isFunction( myValue ); // false
jQuery.isPlainObject( myValue ); // false
jQuery.isArray( myValue ); // true

Example 2:
// Testing the type of various variables.
var myFunction = function() {
    console.log( "hello" );
};
var myObject = {
    foo: "bar"
};
var myArray = [ "a", "b", "c" ];
var myString = "hello";
var myNumber = 3;
var myRegExp = /(\w+)\s(\w+)/;
 
typeof myFunction; // "function"
typeof myObject;   // "object"
typeof myArray;    // "object" -- Careful!
typeof myString;   // "string"
typeof myNumber;   // "number"
typeof null;       // "object" -- Careful!
typeof undefined;  // "undefined"
typeof meh;        // "undefined" -- undefined variable.
typeof myRegExp;   // "function" or "object" depending on environment.
 
 
if ( myArray.push && myArray.slice && myArray.join ) {
    // probably an array (this is called "duck typing")
}
 
if ( Object.prototype.toString.call( myArray ) === "[object Array]" ) {
    // Definitely an array!
    // This is widely considered as the most robust way
    // to determine if a specific value is an Array.
}
[ ---  end  ---- ]

=== [ topic ][ class ][ simulate ] ===
[ --- start ---- ]
var myClass = {
    pupilSize : 50;
    className : "3C12";
}

alert(myClass.className + myClass.pupilSize);
[ ---  end  ---- ]

=== [ topic ][ loop ][ do..while] ===
[ --- start ---- ]
do{
    ...
}while(xxx==yyy)
[ ---  end  ---- ]

=== [ topic ][ loop ][ for...in ] ===
[ --- start ---- ]
function myClass(param){
    this.size = param.shift();
    this.teacher = param.shift();
    this.location = param.shift();
}

var class = new myClass(50, "Mr Ken", "level 3");
var output = "";
for( prop in class){
    output += prop; 
}

for (prop in class){
    output += class[prop]
}
[ ---  end  ---- ]

=== [ topic ][ error handling ] ===
[ --- start ---- ]
- provide javascript version to tag to browser to facilitate debugging
<script type="application/javascript;version=1.7">...</script>

Error Type:
- EvalError
- RangeError
    when do math operation
- ReferenceError
    using resource doesn't exist
- SyntaxError
- TypeError
[ ---  end  ---- ]

=== [ topic ][ error handling ][ try...catch ] ===
[ --- start ---- ]
Example 1:
try{...
} catch (Err) {
    /// print Err.name, Err.message
}

Example 2:
try{
    throw new ReferenceError("description"+data);
    throw TypeError("description"+data);
} catch(Err){
    /// print Err.name, Err.message
}
[ ---  end  ---- ]

=== [ topic ][ error handling ][ onerror ] ===
[ --- start ---- ]
onerror=handleErr;
var txt="";

function handleErr(msg,url,l)
{
    txt="There was an error on this page.\n\n";
    txt+="Error: " + msg + "\n";
    txt+="URL: " + url + "\n";
    txt+="Line: " + l + "\n\n";
    txt+="Click OK to continue.\n\n";
    alert(txt);
    return true;
}

function message()
{
    adddlert("Welcome guest!");
}
[ ---  end  ---- ]

=== [ topic ][ debug ] ===
[ --- start ---- ]
console.log()
console.info()
[ ---  end  ---- ]

=== [ topic ][ debug ][ chrome ] ===
[ --- start ---- ]
- about:appcache-internals
- shift+enter : multiline function editing
- Ctrl + ] and Ctrl + [) shortcuts allow you to move right and left between the
  different tabs
- ? to see all shortcut
> console.log(window)
> $0
> $($0)
then can right click > reveal in element panel
$x(xpath)
> $x('//img')
var frame = document.getElementsByTagName('iframe')[0].contentWindow.document.body;
$x('//'img, frame);

Example 1:
F12 to open chrome dev-tools, then
ctrl + shift + F  == search source
with regular expression
foo\s*=\s*function

Example 2: console
F12 > ESC :
keys(window)
dir(window)
or just type window == dir(window)

Example 3: console
for(var b in window) { 
  if(window.hasOwnProperty(b)) console.log(b); 
}

Example 4: $_ to access last result
> $_

Example 5:  console.dir() - lists out all of the properties of a provided object
> console.dir(document.body)


[ ---  end  ---- ]

=== [ topic ][ debug ][ MutationObserver ] ===
[ --- start ---- ]
- use MutationObserver. Mutation events was deprecated.

html:
<p id="observable" style="color: red">Lorem ipsum</p>

javascript:
var MutationObserver = window.WebKitMutationObserver;

var target = document.querySelector('#observable');

var observer = new MutationObserver(function(mutations) {
  mutations.forEach(function(mutation) {
    console.log('old', mutation.oldValue);
    console.log('new', mutation.target.style.cssText);
  });    
});

var config = { attributes: true, attributeOldValue: true }

observer.observe(target, config);

// click event to change colour of the thing we are observing
target.addEventListener('click', function(ev) {
    observable.style.color = 'green';
    return false;
}, false);
[ ---  end  ---- ]

=== [ topic ][ DOM ] ===
[ --- start ---- ]
- DOM = Document Object Model
- The DOM is a W3C (World Wide Web Consortium) standard.
JavaScript can change all the HTML elements in the page
JavaScript can change all the HTML attributes in the page
JavaScript can change all the CSS styles in the page
JavaScript can remove existing HTML elements and attributes
JavaScript can add new HTML elements and attributes
JavaScript can react to all existing HTML events in the page
JavaScript can create new HTML events in the page
- The HTML DOM is a standard object model and programming interface for HTML. 
  It defines:
The HTML elements as objects
The properties of all HTML elements
The methods to access all HTML elements
The events for all HTML elements
[ ---  end  ---- ]

=== [ topic ][ DOM ][ events ] ===
[ --- start ---- ]
- onresize
- onscroll
- onselect
- onsubmit
- onreset

Examples of HTML events:

When a user clicks the mouse
When a web page has loaded
When an image has been loaded
When the mouse moves over an element
When an input field is changed
When an HTML form is submitted
When a user strokes a key

Example 1:
<h1 onclick="this.innerHTML='Ooops!'">Click on this text!</h1>

Example 2:
function changetext(id) { id.innerHTML="Ooops!"; }
<h1 onclick="changetext(this)">Click on this text!</h1>

Example 3:
<button onclick="displayDate()">Try it</button>
document.getElementById("myBtn").onclick=function(){displayDate()};

Example 4:
<input type="text" id="fname" onchange="upperCase()">

Example 5:
function myFunction() {
    var x=document.getElementById("fname");
    x.value=x.value.toUpperCase();
}
Enter your name: <input type="text" id="fname" onchange="myFunction()">
<p>When you leave the input field, a function is triggered which transforms the 
input text to upper case.</p>

[ ---  end  ---- ]

=== [ topic ][ DOM ][ events ][ onload ] ===
[ --- start ---- ]
Example 1:
function checkCookies() {
if (navigator.cookieEnabled==true) { alert("Cookies are enabled") }
else { alert("Cookies are not enabled") } }
<body onload="checkCookies()">
[ ---  end  ---- ]

=== [ topic ][ DOM ][ events ][ mouse ] ===
[ --- start ---- ]
- ondblclick = on double click

Example 1:
<div onmouseover="mOver(this)" onmouseout="mOut(this)" >Default Text</div>
function mOver(obj) { obj.innerHTML="Thank You" }
function mOut(obj) { obj.innerHTML="Mouse Over Me" }

Example 2: when mouse button is pressed - onmousedown
<div onmousedown="mDown(this)" onmouseup="mUp(this)">Click Me</div>
function mDown(obj) { obj.style.backgroundColor="#1ec5e5"; obj.innerHTML="Release Me" }
function mUp(obj) { obj.style.backgroundColor="#D94A38"; obj.innerHTML="Thank You" }

Example 3:
.highlight { color: yellow; }
.dim { color: grey; }
function changeClass(id, class){ document.getElementById(id).setAttribute("class", class);}
<p id="KenPara" onmouseover="changeClass('KenPara', 'highlight')"
                onmouseout ="changeClass('KenPara', 'dim')"

Example 4: using "this" for example 3
function changeClass(id, class){ this.setAttribute("class", class);}
<p id="KenPara" onmouseover="changeClass(this, 'highlight')"
                onmouseout ="changeClass(this, 'dim')"
[ ---  end  ---- ]

=== [ topic ][ DOM ][ node ] ===
[ --- start ---- ]
everything in an HTML document is a node:
The entire document is a document node
Every HTML element is an element node
The text inside HTML elements are text nodes
Every HTML attribute is an attribute node
All comments are comment nodes

In a node tree, the top node is called the root (or root node)
Every node has exactly one parent, except the root (which has no parent)
A node can have a number of children
Siblings (brothers or sisters) are nodes with the same parent

Example 1:
<html>
  <head>
    <title>DOM Tutorial</title>
  </head>
  <body>
    <h1>DOM Lesson one</h1>
    <p>Hello world!</p>
  </body>

</html>

-- Decoding --
<html> is the root node
<html> has no parents
<html> is the parent of <head> and <body>
<head> is the first child of <html>
<body> is the last child of <html>
and
<head> has one child: <title>
<title> has one child (a text node): "DOM Tutorial"
<body> has two children: <h1> and <p>
<h1> has one child: "DOM Lesson one"
<p> has one child: "Hello world!"
<h1> and <p> are siblings

Example 2:
<p id="intro">Hello World!</p>
txt=document.getElementById("intro").childNodes[0].nodeValue;
/// txt=document.getElementById("intro").firstChild.nodeValue; ///similar
document.write(txt);
/// output Hello World!
[ ---  end  ---- ]

=== [ topic ][ DOM ][ Root Nodes ] ===
[ --- start ---- ]
document.documentElement - The full document
document.body - The body of the document

Example 1:
alert(document.body.innerHTML);
[ ---  end  ---- ]

=== [ topic ][ DOM ][ nodeName ] ===
[ --- start ---- ]
The nodeName property specifies the name of a node.
nodeName is read-only
nodeName of an element node is the same as the tag name
nodeName of an attribute node is the attribute name
nodeName of a text node is always #text
nodeName of the document node is always #document
Note: nodeName always contains the uppercase tag name of an HTML element.

The nodeValue Property
The nodeValue property specifies the value of a node.
nodeValue for element nodes is undefined
nodeValue for text nodes is the text itself
nodeValue for attribute nodes is the attribute value

Element type	NodeType
Element           1
Attribute         2
Text              3
Comment           8
Document          9
[ ---  end  ---- ]

=== [ topic ][ DOM ][ node ] ===
[ --- start ---- ]
-document.body.insertBefore(element_to_be_inserted, selected_element)

Example 1:
var p = document.createElement("p");
p.setAttribute("id", "KenParaId");
p.innerHTML = "a paragraph.";
document.body.insertBefore(p, document.getElementById("oldPara"));
document.body.removeChild(document.getElementById("KenParaId"));
[ ---  end  ---- ]

=== [ topic ][ DOM ][ nodelist ] ===
[ --- start ---- ]
Example 1:
var x=document.getElementsByTagName("p");
y=x[1];   /// select the second <p>

Example 2:
x=document.getElementsByTagName("p");
for (i=0;i<x.length;i++) {
document.write(x[i].innerHTML);
document.write("<br />");
}
[ ---  end  ---- ]

=== [ topic ][ DOM ][ CSS ] ===
[ --- start ---- ]
var css = document.styleSheets[0];   /// first <style>...</style> tag
var rules = css.cssRules;
for (var i=0; i<rules.length; i++){
    var rule = rules[i];
    /// rule.selectorText;   /// the selector, .e.g h1, h2, p...
    
    var style = rule.style;
    for (var j=0; j < style.length; j++){
        var name = styles[j];  /// style name, e.g. background, color, font-weight...
        /// style.getPropertyValue(name) /// print the style rules, e.g. "red", 15px..
    }
}
[ ---  end  ---- ]

=== [ topic ][ cookies ] ===
[ --- start ---- ]
writing to cookies:
- Cookies are saved in name-value pairs like: username=John Doe 
document.cookie="username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT";
- With a path parameter, you can tell the browser what path the cookie 
belongs to. By default, the cookie belongs to the current page.
document.cookie="username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/";

reading a cookies:
var x = document.cookie;

changing a cookies: same as the way writing to it
document.cookie="username=John Smith; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/";

delete a cookies:
- no need specify a cookie value
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT"; 

Example 1:

function setCookie(cname,cvalue,exdays) {
    var d = new Date();
    /// set to expire in (exdays * one day)
    d.setTime(d.getTime()+(exdays*24*60*60*1000));
    var expires = "expires="+d.toGMTString();
    document.cookie = cname+"="+cvalue+"; "+expires;
}

function getCookie(cname)
{
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) 
      {
      var c = ca[i].trim();
      // name.length is "cname ="
      // c.length is "cname = value"
      if (c.indexOf(name)==0) return c.substring(name.length,c.length);
      }
    return "";
}

function checkCookie()
{
var user=getCookie("username");
if (user!="")
  {
  alert("Welcome again " + user);
  }
else 
  {
  user = prompt("Please enter your name:","");
  if (user!="" && user!=null)
    {
    setCookie("username",user,30);
    }
  }
}

</script></head>

<body onload="checkCookie()"></body>
[ ---  end  ---- ]

=== [ topic ][ bind ] ===
[ --- start ---- ]
bind() method creates a new function that, when called, has its this keyword set
to the provided value, with a given sequence of arguments preceding any provided
when the new function is called.

Example 1:
// A function created using Function.bind()
 
var myName = "the global object";
var sayHello = function() {
    console.log( "Hi! My name is " + this.myName );
};
var myObject = {
    myName: "Rebecca"
};
var myObjectHello = sayHello.bind( myObject );
 
sayHello();      // "Hi! My name is the global object"
myObjectHello(); // "Hi! My name is Rebecca"

[ ---  end  ---- ]

=== [ topic ][ this ] ===
[ --- start ---- ]
- If the function is invoked using Function.call() or Function.apply(), this will
    be set to the first argument passed to .call()/.apply(). If the first argument
    passed to .call()/.apply() is null or undefined, this will refer to the global
    object (which is the window object in web browsers).
- If the function being invoked was created using Function.bind(), this will be
  the first argument that was passed to .bind() at the time the function was
  created.
- If the function is being invoked as a method of an object, this will refer to
  that object.
- Otherwise, the function is being invoked as a standalone function not attached
    to any object, and this will refer to the global object.

Example 1:
this.x = 9; 
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX;
getX(); // 9, because in this case, "this" refers to the global object

// create a new function with 'this' bound to module
var boundGetX = getX.bind(module);
boundGetX(); // 81

Example 2:
// A function being attached to an object at runtime.
var myName = "the global object";
var sayHello = function() {
    console.log( "Hi! My name is " + this.myName );
};
var myObject = {
    myName: "Rebecca"
};
var secondObject = {
    myName: "Colin"
};
 
myObject.sayHello = sayHello;
secondObject.sayHello = sayHello;
 
sayHello();              // "Hi! My name is the global object"
myObject.sayHello();     // "Hi! My name is Rebecca"
secondObject.sayHello(); // "Hi! My name is Colin"

Example 3:
var myNamespace = {
    myObject: {
        sayHello: function() {
            console.log( "Hi! My name is " + this.myName );
        },
        myName: "Rebecca"
    }
};

/// calling inner function directly, this will be undefined
var hello = myNamespace.myObject.sayHello;
 
hello(); // "Hi! My name is undefined"

Example 4:
var myNamespace = {
    myObject: {
        sayHello: function() {
            console.log( "Hi! My name is " + this.myName );
        },
        myName: "Rebecca"
    }
};
 
var obj = myNamespace.myObject;
 
obj.sayHello(); // "Hi! My name is Rebecca"

[ ---  end  ---- ]

=== [ topic ][ scope ] ===
[ --- start ---- ]
- var define the variable is local, without var, the variable is global

Example 1:
function myFunc() {
    var x = 5;
}
console.log( x ); // ReferenceError: x is not defined

Example 2:
function myFunc() {
    x = 5;
}
console.log( x ); // 5

Example 3: 
- immediately invoked function expression provide way to avoid global variable
- Wrapping everything in a function which is then immediately invoked means all
  the variables within that function are bound to the local scope. 
- At the very end you can then expose all your methods by binding the jQuery object to the
  window, the global object.
(function() {
    var jQuery = { /* All my methods go here. */ };
    window.jQuery = jQuery;
})();

Example 4:
    - inner function has access to outer function variable
function outer() {
    var x = 5;
    function inner() {
        console.log( x );
    }
    inner(); // 5
}

Example 5:
var foo = "world";
 
var sayHello = function() {
    var foo = "hello";
    console.log( foo );
};
 
sayHello(); // "hello"
 
console.log( foo ); // "world"

Example 6:
- When you reference a global variable within a function, that function can see
changes to the variable value after the function is defined.
var myFunction = function() {
    var foo = "hello";
    var myFn = function() {
        console.log( foo );
    };
    foo = "world";
    return myFn;
};
 
var f = myFunction();
 
f(); // "world"

Example 7:
(function() {
    var baz = 1;
    var bim = function() {
        console.log( baz ); };
    /// global variable
    bar = function() {
        console.log( baz ); };
})();

console.log( baz ); // baz is not defined outside of the function
bar(); //  1
bim(); // ReferenceError: bim is not defined
[ ---  end  ---- ]

=== [ topic ][ closures ][ scope ] ===
[ --- start ---- ]

Example 1:
for ( var i = 0; i < 5; i++ ) {
    setTimeout(function() {
        console.log( "no closure: "+i );
    }, i * 100 );
}

// Using a closure to create a new private scope
// fix: “close” the value of i inside createFunction, so it won't change
var createFunction = function( i ) {
    return function() {
        console.log( "closure: "+i);
    };
};
 
for ( var i = 0; i < 5; i++ ) {
    setTimeout( createFunction( i ), i * 100 );
}

output:
    /*
no closure: 5 
closure: 0 
no closure: 5 
closure: 1 
no closure: 5 
closure: 2 
no closure: 5 
closure: 3 
no closure: 5 
closure: 4 
   */

Example 2:
// Using a closure to access inner and outer object instances simultaneously.
var outerObj = {
    myName: "outer",
    outerFunction: function() {
        // provide a reference to outerObj through innerFunction"s closure
        var self = this;
        var innerObj = {
            myName: "inner",
            innerFunction: function() {
                console.log( self.myName, this.myName ); // "outer inner"
            }
        };
 
        innerObj.innerFunction();
 
        console.log( this.myName ); // "outer"
    }
};
 
outerObj.outerFunction();
[ ---  end  ---- ]

=== [ topic ][ closure ][ bind ] ===
[ --- start ---- ]
- Closures can be particularly useful when dealing with callbacks. However, it is
often better to use Function.bind, which will avoid any overhead associated with
scope traversal.
- Function.bind is used to create a new function. When called, the new function
then calls itself in the context of the supplied this value, using a given set
of arguments that will precede any arguments provided when the new function was
initially called.
- As .bind() is a recent addition to ECMAScript 5, it may not be present in all
browsers, which is something to be wary of when deciding whether to use it.
However, it's possible to work around support by using this shim from MDN:

Example 1:

2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
// Let's manipulate "this" with a basic example.
var user = "johnsmith";
var module = {
    getUser: function() {
        return this.user;
    },
    user: "janedoe"
};
 
// module.getUser() is called where "module" is "this"
// and "module.user" is returned.
 
// janedoe
module.getUser();
 
// let's now store a reference in the global version of "this"
var getUser = module.getUser;
 
// getUser() called, "this" is global, "user" is returned
 
// johnsmith
getUser();
 
// store a ref with "module" bound as "this"
var boundGetUser = getUser.bind( module );
 
// boundGetUser() called, "module" is "this" again, "module.user" returned.
 
// janedoe
boundGetUser();
[ ---  end  ---- ]

=== [ topic ][ framework ] ===
[ --- start ---- ]
    jQuery
    Prototype
    MooTools
YUI - The Yahoo! User Interface Framework is a large library that covers a lot 
     of functions, from simple JavaScript utilities to complete internet widgets.
Ext JS - Customizable widgets for building rich Internet applications.
Dojo - A toolkit designed around packages for DOM manipulation, events, widgets, and more.
script.aculo.us - Open-source JavaScript framework for visual effects and interface behaviors.
UIZE - Widgets, AJAX, DOM, templates, and more.
[ ---  end  ---- ]

=== [ topic ][ framework ][ CDN ] ===
[ --- start ---- ]
- Content Delivery Networks
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js">
</script> 
[ ---  end  ---- ]

=== [ topic ][ closure compiler ] ===
[ --- start ---- ]
- to download: wget http://dl.google.com/closure-compiler/compiler-latest.zip
- minified, concatenate and check for error in javascript to make it 
  smaller and run faster on the client
- a map file is needed to debug as if in the development site
- to generate the map file use:
java -jar compiler.jar \ 
     --js script.js \
     --create_source_map ./script-min.js.map \
     --source_map_format=V3 \
     --js_output_file script-min.js
[ ---  end  ---- ]

=== [ topic ][ problem ][ call dom before it exits ] ===
[ --- start ---- ]
Example 1: Problem
<!doctype html>
<html>
<head>
    <script>
    // Attempting to access an element too early will have unexpected results.
    var title = document.getElementById( "hello-world" );
    console.log( title );
    </script>
</head>
<body>
<h1 id="hello-world">Hello World</h1>
</body>
</html>

Solution: Move script to the end
<!doctype html>
<html>
<head></head>
<body>
 
<h1 id="hello-world">Hello World</h1>
<script>
// Moving the script to the bottom of the page will make sure the element exists.
var title = document.getElementById( "hello-world" );
console.log( title );
</script>
 
</body>
</html>
[ ---  end  ---- ]

=== [ topic ][ do and dont ][ script tag ] ===
[ --- start ---- ]
Title: language="javascript"
This attribute has been deprecated. It was used to select other programming 
languages and specific versions of JavaScript. You don't need it. Don't use it.

Title: type="text/javascript"
- optional
Since Netscape 2, the default programming language 
in all browsers has been JavaScript. In XHTML, this attribute is required and 
unnecessary. In HTML, it is better to leave it out. The browser knows what to 
do.

Do not use the <!-- //--> hack with scripts. It was intended to prevent scripts 
from showing up as text on the first generation browsers Netscape 1 and Mosaic. 
It has not been necessary for many years. <!-- //--> is supposed to signal an 
HTML comment. Comments should be ignored, not compiled and executed. Also, HTML 
comments are not to include --, so a script that decrements has an HTML error.

Title: defer
- This attribute was intended to alter the timing of component loading in pages. 
- It is not well supported and should not be used.

Title: for="name" event="name"
- This attribute is a Microsoft feature for declaring event handlers. 
- It is not standard. Don't use it.

Title: Placement
- <script> will block downloading of other page components
- better to place at the end before </body>
- if the script is used by another script/function, place it before that script
[ ---  end  ---- ]

=== [ topic ][ do and dont ][ document.write ] ===
[ --- start ---- ]
- The document.write write into the HTML content of the page. 
- better to use .innerHTML and .createElement or HTML cloning patterns. 
- Use of document.write should be avoided.
- document.write is recklessly dependent on timing:
    == if document.write is called before the onload event, it appends or insert 
       text into page
    == If document.write is called after onload, it completely replaces the page!
- document.write encourages bad structure, in which script and markup are intermingled. 
- A cleaner structure has minimal interaction between markup and script.
[ ---  end  ---- ]

=== [ topic ][ problem ] ===
[ --- start ---- ]
Problem: apache log at /var/log/apache2/error.log shows the following:
File does not exist: /home/knxy/public_html/php/jquery-2.0.3.min.map, referer: http://localhost/php/helloworld.html
solution: refer to closure compiler section to compiler the map file for it
[ ---  end  ---- ]

=== [ topic ][ book ] ===
[ --- start ---- ]
O'Reilly:
JavaScript: The Definitive Guide (4th Edition) by David Flanagan
Dynamic HTML (2nd Edition) by Danny Goodman.
[ ---  end  ---- ]

=== [ topic ][ to know ] ===
[ --- start ---- ]
- lazy loading or on demand script loading
[ ---  end  ---- ]
